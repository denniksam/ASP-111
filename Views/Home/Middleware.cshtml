@{
    ViewData["Title"] = "Middleware";
}

<div class="text-center">
    <h1 class="display-4">Middleware: ПО промежуточного слоя</h1>
</div>

<p>
    Идея Middleware заключается в создании некого "бутылочного горлышка",
    через которое проходят все запросы (для всех контроллеров, методов и т.п.)
</p>
<p>
    Middleware образует цепочку, в которой каждое звено передает управление
    следующему. Последнее звено запускает "обратный ход" передавая ответ
    по всем звеньям в обратном порядке. Существует возможность прервать
    обработку на любом из звеньев.
</p>
<p>
    Middleware может быть много, поэтому их описывают в отдельной папке
    проекта. Классы Middleware включаются инструкциями 
    <code>UseMiddleware&lt;TheClass>()</code>, однако традиция - использовать
    классы расширения, позволяющие создавать инструкции <code>UseTheClass()</code>.
    Поэтому в файле Middleware часто идут два класса - сама логика и
    класс-расширение.
</p>
<p>
    Один из примеров Middleware - маркер. Просто в контекст устанавливается
    некоторое значение, и это есть признак того, что запрос прошел правильный
    путь.
    Маркер: <strong>@ViewData["marker"]</strong>
</p>
<p>
    Использование служб (инъекция) в Middleware. Поскольку конструктор
    классов Middleware "занят" под связывание цепочки вызовов Middleware,
    инъекция через него служб невозможна. Также Middleware имеет Scope
    Singleton (не пересоздается, всегда один объект), поэтому инъекция
    в его конструктор служб с другим временем существования невозможна.
    В итоге, инъекция в Middleware происходит в метод InvokeAsync / Invoke
</p>